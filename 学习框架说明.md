[toc]

## 写在最前面的原因：src 的地址映射

不要用@,因为这里引入图标库的冲突，这里使用~。
配置一下 tsconfig.js

```
    "paths": {
      "~/*": ["src/*"]
    }

```

# 1.unplugin-icons---自动引入图标库

模块化自动引入图标库
比如找见一个 ep:user
<ep:user />

就可以了

# 2.组件自动引入各种文件

虽然 setup 加到 script 中后，可以不用注册，但是需要 import
还想更懒惰吗，不要 import
现在只要在 src/components 下定义的组件都将会按需引入，即 import 是不需要的
但是 native-ui 可以使用。

但是 element-plus

# 3.SWR 使用

SWR 是更现代的请求方式，具体可见文章 👉 SWR。

而 vue-request 是一个 SWR 的 Vue 版本请求库。

```
仅需一行代码，你就可以简化项目中数据请求的逻辑，并立即拥有以下这些不可思议的特性：

极速、轻量、可重用的 数据请求
内置 缓存 和重复请求去除
实时 体验
传输和协议不可知
支持 SSR / ISR / SSG
支持 TypeScript
React Native


```

# 4.进度条实现和配色

跳转进度条由 nprogress 实现，可在 src/styles/main.css 中调整配色。

# 5. 插件自动加载支持

引入各种插件，比如 ponia，或是 vue-router

// src/modules/router.ts

import { App } from 'vue'

// 省略各种配置

// 导出 default 接口
export default (app: App) => app.use(router)

# 6.自动引入 vue 的，vue-router 的 api 内容，vueUse

```
vue
pinia
vueuse
vue-router

```

配置

```
npm i -D unplugin-auto-import
import AutoImport from 'unplugin-auto-import/vite'
AutoImport
		// 自动导入部分
		AutoImport({
			dts: './presets/types/auto-imports.d.ts',
			imports: [
				'vue',
				'pinia',
				'vue-router',
				'@vueuse/core'
			],
			// resolvers: [ElementPlusResolver()]
		})

```

```
AutoImport({
  // targets to transform
  include: [
    /\.[tj]sx?$/, // .ts, .tsx, .js, .jsx
    /\.vue$/, /\.vue\?vue/, // .vue
    /\.md$/, // .md
  ],

  // global imports to register
  imports: [
    // presets
    'vue',
    'vue-router',
    // custom
    {
      '@vueuse/core': [
        // named imports
        'useMouse', // import { useMouse } from '@vueuse/core',
        // alias
        ['useFetch', 'useMyFetch'] // import { useFetch as useMyFetch } from '@vueuse/core',
      ],
      'axios': [
        // default imports
        ['default', 'axios'] // import { default as axios } from 'axios',
      ],
      '[package-name]': [
        '[import-names]',
        // alias
        ['[from]', '[alias]']
      ]
    }
  ],


```

## vue-request 和 axios

useRequest 接收了一个 service 函数。service 是一个异步的请求函数，换句话说，你可以使用 axios 来获取数据，然后返回一个 Promise。更具体的说明可以在文档中查看。

useRequest 还返回了三个值， data、loading 和 error

```
  const { data, loading, error } = useRequest(service);

```

### 一些很酷的特性

VueRequest 有非常多的特性，如 错误重试、缓存、分页、节流、防抖...，这里列举两个个比较酷的特性

### 手动触发请求

```
默认情况下，我们将会在组件挂载时，自动帮你触发绑定的请求。当然，如果你想自己控制触发请求的时机，你可以通过传入 manual 选项，来禁止挂载时的默认请求，然后通过 run() 或者 runAsync() 来触发请求。
  const { run, data, loading } = useRequest(testService, {
      manual: true,
    });

    const handleLogin = () => {
      run(name.value);
    };

```

### 1.聚焦页面时自动重新请求

```
const { data, error, run } = useRequest(getUserInfo, {
  refreshOnWindowFocus: true,
  refocusTimespan: 1000, // 请求间隔时间
});

```

### 轮训数据

```
const { data, error, run } = useRequest(getUserInfo, {
  pollingInterval: 1000, // 请求间隔时间
});


```

### 请求防抖

```
const { data, loading, run } = useRequest(testService, {
      debounceInterval: 300,
      manual: true,
    });


```

### 输入 input 框节流

```
    const { data, loading, run } = useRequest(testService, {
      throttleInterval: 1000,
      manual: true,
    });

    const handleInput = () => {
      run();
    };


```

### 错误重试

```

const { data } = useRequest(getUser, {
  errorRetryCount: 5, // it will retry 5 times
  errorRetryInterval: 3 * 1000, // The retry interval is 3 seconds
});


```

## 08vite 语法糖增强插件

vite-plugin-vue-setup-extend
Vue3 的 setup 语法糖是个好东西，但使用 setup 语法带来的第一个问题就是无法自定义 name，而我们使用 keep-alive 往往是需要 name 的，解决这个问题通常是通过写两个 script 标签来解决，一个使用 setup，一个不使用，但这样必然是不够优雅的

```
import { defineConfig } from 'vite'
import VueSetupExtend from 'vite-plugin-vue-setup-extend'
export default defineConfig({
  plugins: [
    VueSetupExtend()
  ]

})


```

## 忽略文件后缀

```

import { defineConfig } from 'vite'
export default defineConfig({
  resolve: {
    extensions: ['.js', '.ts', '.jsx', '.tsx', '.json', '.vue']
  }
})


```

## 新增数据持久化插件

```
import piniaPersist from 'pinia-plugin-persist'
一些头像，登录态，刷新不清楚



```

## 找不到模块“./counter”或其相应的类型声明。

我在使用时出现这个问题的原因是因为配置的快捷路径导致的
必须在 vite 和 tsconfig 中都配置

## pinia 配置

### 使用方式两种使用方式组合式 API

```
import { defineStore } from 'pinia';
//创建出来一个个命名的store
export const roleBasic = defineStore('roleBasic', () => {
  const basic = reactive<IRoleBasic>({
    name: '',
    profession: '',
    sex: ''
  });

  function setItem(data: IRoleBasic) {
    if (typeof data === 'object') {
      Object.keys(data).forEach((key: string) => {
        if (basic.hasOwnProperty(key)) {
          basic[key] = data[key];
        }
      });
    }
  }

  return { basic, setItem };
});


```

### 选项式 API 使用

```
//
import { defineStore } from 'pinia'
export const userStore = defineStore('user', {
    state: () => {
        return {
            count: 1,
            arr: []
        }
    },
    getters: {},
    actions: {}
})


```

### 使用方式：访问 store，响应式访问最新 store

注意：// 解构
// const { count } = userStore()
解构赋值出来的不是响应式的。
需要使用方法

```
import { storeToRefs } from 'pinia'
import { userStore } from '../store'
const { count } = storeToRefs(userStore())

```

### get 这个和 Vuex 的 getters 一样，也有缓存功能

```
getters: {
    // 方法一，接收一个可选参数 state
    myCount(state){
        console.log('调用了') // 页面中使用了三次，这里只会执行一次，然后缓存起来了
        return state.count + 1
    },
    // 方法二，不传参数，使用 this
    // 但是必须指定函数返回值的类型，否则类型推导不出来
    myCount(): number{
        return this.count + 1
    }
}


```

### 更新数据方式 action

```
1.方法1：直接更新数据
import { userStore } from '../store'
const user_store = userStore()
user_store.count++

2.方法2：更新多个数据，建议用 $patch 批量更新
对象方式和函数方式
对象方法
user_store.$patch({
  count:user_store
})
函数方法
user_store.$patch( state => {
      state.count++
      state.arr.push(1)
  })

```

## 支持 eslint

```
npm install eslint vite-plugin-eslint --save-dev

插件1：import eslint from 'vite-plugin-eslint'

插件2：eslint-plugin-vue

插件3,4,ts中
❯ pnpm i @typescript-eslint/eslint-plugin @typescript-eslint/parser -D

```
